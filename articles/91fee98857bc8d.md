---
title: "å¤šé‡å®Ÿè¡Œã‚’é˜²ããŸã‚ã«Goã§ã‚¯ãƒ©ã‚¦ãƒ‰ç’°å¢ƒã§ã®æ’ä»–åˆ¶å¾¡ã‚’è€ƒãˆã‚‹"
emoji: "ğŸ¯"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["golang"]
published: false
---

# ã¯ã˜ã‚ã«

## TL;DR
- ã‚¯ãƒ©ã‚¦ãƒ‰ç’°å¢ƒã§ã¯åˆ†æ•£ãƒ­ãƒƒã‚¯ã«ã™ã‚‹ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã§ã¯èµ·ããªã„ãŒã€æœ¬ç•ªç’°å¢ƒã§èµ·ãã‚‹ã¨ã„ã†æ’ä»–åˆ¶å¾¡ã®å•é¡Œã‚’å›é¿ã§ãã‚‹ã€‚


#ã€€èƒŒæ™¯

ã‚ˆãã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒ“ã‚¹ã®å‹‰å¼·ã‚’ã—ã¦ã„ã‚‹æ™‚ã€ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚’èª­ã‚“ã§å†™çµŒã—ã¦ã„ãŸãŒã€æ’ä»–åˆ¶å¾¡ã«å¯¾ã—ã¦å…¨ãã¨è¨€ã£ã¦ã„ã„ã»ã©è§¦ã‚Œã¦ã„ãªã„ã€‚

```go
func main() {
	r := gin.Default() // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® Gin ã‚¨ãƒ³ã‚¸ãƒ³ (ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä»˜ã)
	r.GET("/ping", func(c *gin.Context) { // GET /ping ãƒãƒ³ãƒ‰ãƒ©
		c.JSON(200, gin.H{"message": "pong"})
	})
	r.Run() // ã‚µãƒ¼ãƒèµ·å‹•
}
```

åŒæ™‚å®Ÿè¡Œã«å¯¾ã—ã¦ã©ã†ã™ã‚‹ã‚“ã ã‚ã†ã¨ã„ã†ç–‘å•ã€‚


# Mutexã‚’å°å…¥

Mutexã‚’å°å…¥ã™ã‚Œã°ã„ã„ã€‚

```go
package service

import (
	"sync"
	"sync/atomic"
)

var globalLock = &lockManager{}

type lockRef struct {
	mu    sync.Mutex
	count int32
}

func newLockRef() *lockRef {
	return &lockRef{
		count: 1,
	}
}

// LockManager ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã”ã¨ã«ãƒ­ãƒƒã‚¯ã‚’ç®¡ç†ã™ã‚‹æ§‹é€ ä½“
type lockManager struct {
	locks sync.Map
}

type LockManager interface {
	Lock(uid string)
	Unlock(uid string)
}

func NewLockManager() LockManager {
	return globalLock
}

// Lock ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã«åŸºã¥ã„ã¦ãƒ­ãƒƒã‚¯ã‚’ç²å¾—ã™ã‚‹
func (lm *lockManager) Lock(uid string) {
	for {
		actual, loaded := lm.locks.LoadOrStore(uid, newLockRef())
		lRef := actual.(*lockRef)
		if loaded {
			// æ—¢å­˜ã®å ´åˆã¯å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã€åŠ ç®—ã™ã‚‹
			if atomic.LoadInt32(&lRef.count) == 0 {
				continue
			}
			atomic.AddInt32(&lRef.count, 1)
		}
		lRef.mu.Lock()
		break
	}
}

// Unlock ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã—ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã«ãªã£ãŸã‚‰ãƒãƒƒãƒ—ã‹ã‚‰å‰Šé™¤
func (lm *lockManager) Unlock(uid string) {
	if value, ok := lm.locks.Load(uid); ok {
		lRef := value.(*lockRef)
		lRef.mu.Unlock()
		if atomic.AddInt32(&lRef.count, -1) == 0 {
			lm.locks.Delete(uid)
		}
	}
}
```

#ã€€å•é¡Œç‚¹

æˆ‘ãªãŒã‚‰ã‚ˆãã§ããŸã€‚
ãƒ­ãƒ¼ã‚«ãƒ«ã§æ’ä»–åˆ¶å¾¡ãŒã§ãã¦å®‰å¿ƒã—ã¦ã„ãŸã€‚

ã—ã‹ã—ã€æ°—ã¥ã„ãŸã€‚
ã“ã‚Œã¯åŒä¸€ãƒ—ãƒ­ã‚»ã‚¹å†…ã§ã—ã‹ã€æ’ä»–åˆ¶å¾¡ãŒã§ãã¦ã„ãªã„ã€‚

æ˜¨ä»Šã¯ã‚¯ãƒ©ã‚¦ãƒ‰ç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚
ãã®éš›ã€æ°´å¹³ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ã•ã‚Œã‚‹ã¨ã“ã‚Œã¯æ’ä»–ã§ããªã„ã€‚

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯åŒä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚»ãƒƒã‚·ãƒ§ãƒ³å†…ã®å¤šé‡å®Ÿè¡Œã‚’é˜²ã„ã§ãã‚Œã‚‹ã ã‘ã§ã€ãƒãƒƒãƒå‡¦ç†ã¨é‡ãªã£ãŸã‚Šã€è¤‡æ•°ç«¯æœ«ã®ãƒ­ã‚°ã‚¤ãƒ³ã§ç°¡å˜ã«å´©å£Šã—ã¦ã—ã¾ã†ã€‚


# åˆ†æ•£ãƒ­ãƒƒã‚¯ã‚’å°å…¥ã™ã‚‹
ã¾ãšã¯ã€redisã‚’ä½¿ã„ã¾ã™ã€‚

```go
package service

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/hololive/holoearth-ugc-backend/infrastructure/driver"
)

// LockManager ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã”ã¨ã«ãƒ­ãƒƒã‚¯ã‚’ç®¡ç†ã™ã‚‹æ§‹é€ ä½“
type lockManager struct {
	client Redsync
}

//go:generate mockgen -source=$GOFILE -destination=./mock/mock_$GOFILE -package mock
type LockManager interface {
	LockWithContext(ctx context.Context, uid string) (func(), error)
}

func NewLockManager(redsyncClient driver.RedisDriver) LockManager {
	return &lockManager{
		redsyncClient: redsyncClient,
	}
}

// LockWithContext
func (l *lockManager) LockWithContext(ctx context.Context, uid string) (func(), error) {
	if uid == "" {
		return nil, fmt.Errorf("uid is empty")
	}

	lockKey := "user-lock:" + uid

	mutex, err := l.client.Lock(ctx, lockKey)
	if err != nil {
		return nil, err
	}

	// unlocké–¢æ•°ã‚’è¿”ã™ã€‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã‚’ç”¨æ„ã—ã¦ã€å‘¼ã³å‡ºã—å…ƒã«deferã§èª­ã‚“ã§ã‚‚ã‚‰ã†ã€‚
	unlockFunc := func() {
		err := l.client.UnLock(context.Background(), mutex)
        if err != nil {
			slog.Warn("unlock failed", "error", err, "uid", uid)
		}
	}

	return unlockFunc, nil
}

```

```go

type Redsync interface {
	Lock(ctx context.Context, key string, tries, ttl int) (*redsync.Mutex, error)
	UnLock(ctx context.Context, mutexlist *redsync.Mutex) error
}


type redsync struct {
	rs        *redsync.Redsync
}

func (r *redsync) Lock(ctx context.Context, key string) (*redsync.Mutex, error) {
	mutex := r.rs.NewMutex(key)
	err := mutex.LockContext(ctx)
	if err != nil {
		return nil, err
	}
	return mutex, nil
}

func (r *redsync) UnLock(ctx context.Context, mutex *redsync.Mutex) error {
    ok, err := mutex.UnlockContext(ctx)
    if err != nil {
        return err
    }
    if !ok {
        return fmt.Errorf("unlock failed: not owner of lock")
    }
    return nil
}

```